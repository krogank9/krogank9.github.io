var popSize = 20;

var networks = [];

// 9 inputs. 8 joint rotations: shoulder, elbow, hip, knee. & also the body's rotation
// 8 outputs, each new joint motor speed
// 8 hidden layers, 9 neurons per hidden layer
for(var i=0; i < popSize; i++)
	networks.push(new Brainwave.Network(9, 8, 1, 1));

var genetics = new Brainwave.Genetics(popSize, networks[0].getNumWeights());

// Use the weights generated by the Genetics object
for(var i=0; i<popSize; i++)
	networks[i].importWeights(genetics.population[i].weights);
	//networks[i].importWeights(JSON.parse(saved_weights));
	
var upper_body = null;
var arm_joints = [];
var leg_joints = [];
var all_joints = [];
var max_rads = 2*Math.PI;
function normalize_rads(rads) {
	return ((rads%max_ang)+max_rads)%max_rads;
}
function rad_to_fraction(rads) {
	return rads/max_rads;
}
function get_joint_angles() {
	var arr = [];
	for(i=0; i<all_joints.length; i++)
		arr.push(rad_to_fraction(all_joints[i].GetJointAngle()));
	return arr;
}
function set_joint_motors(arr) {
	// 0.5 = 0 speed
	// 1.0 = max torque
	// 0.0 = max torque in the negative direction
	
	for(i=0; i<all_joints.length; i++) {
		var j = all_joints[i];
		// make between -1 and 1
		var val = (arr[i] - 0.5)*2;
		var speed = val*j.GetMotorTorque();
		j.SetMotorSpeed(speed);
	}
}

// get a measure of how close 1 angle is to another, between 0 and 1
function get_angle_closeness(ang1, ang2) {
	var closeness = 1.0 - Math.abs(find_angle_difference(ang1, ang2))/Math.PI;
	if(closeness > 1)
		closeness = 1;
	if(closeness < 0)
		closeness = 0;
	return closeness;
}

function get_joint_fitness(j) {
	var start_ang = j.start_angle;
	var cur_ang = j.GetJointAngle();
	var range1 = Math.abs( find_angle_difference(start_ang, j.GetUpperLimit()) );
	var range2 = Math.abs( find_angle_difference(start_ang, j.GetLowerLimit()) );
	var max_range = range2 > range1 ? range2 : range1;
	var diff = find_angle_difference(cur_ang, start_ang);
	var fitness = 1 - Math.abs(diff/max_range);
	return fitness;
}

// measure how close all the legs are to their starting angle. returns 1 for fit 0 for unfit
function get_leg_fitness() {
	var total = 0;
	for(var i=0; i<leg_joints.length; i++) {
		var j = leg_joints[i];
		var fitness = get_joint_fitness(j);
		total += fitness;
	}
	total /= leg_joints.length;
	if(total > 1)
		total = 1;
	if(total < 0)
		total = 0;
	return total;
}

function get_body_fitness() {
	return get_angle_closeness(upper_body.GetAngle(), 0)
}

function get_fitness() {
	var leg = get_leg_fitness();
	var body = get_body_fitness();
	var fitness = (leg+body)/2;
	return fitness;
}

var max_fitness = 0;
var best_net = 0;
var generation = 1;
var max_generations = 20;
function start_training() {
	if(generation > max_generations) {
		console.log('done training after '+(generation-1)+' generations.');
		reset_b2d_world();
		update_world();
		return;
	}
	
	// For each network in the population, run a box2d simulation for 300 steps.
	// Fitness =
	// How well the upper body able to stay upright for how long
	// & How well the leg joints were about to stay upright for how long
	for (var i = 0; i < popSize; i++) {
		reset_b2d_world();
		var fitness = 0;
		var num_steps = 2000;
		for(var s=0; s<num_steps; s++) {
			step_world();
			var inputs = get_joint_angles().concat([rad_to_fraction(upper_body.GetAngle())]);
			var outputs = networks[i].run(inputs);
			set_joint_motors(outputs);
			
			fitness += get_leg_fitness();
		}
		
		fitness /= num_steps;

		if(fitness > 1)
			fitness = 1;
		else if(fitness < 0)
			fitness = 0;
		
		if(fitness > max_fitness) {
			max_fitness = fitness;
			best_net = i;
		}

		genetics.population[i].fitness = fitness;
	}

	// After you have decided on a fitness for each network, we can use the genetics
	// object to evolve them based on the results
	genetics.epoch(genetics.population);

	// Like at the start, import the weights generated by the Genetics object again.
	// This time they were 'evolved' based on which had the best fitness.
	for (var i = 0; i < popSize; i++)
		networks[i].importWeights(genetics.population[i].weights);
		
	console.log(generation+'/'+max_generations+', best_net: networks['+best_net+'] at '+max_fitness+' fitness.');
	++generation;
	setTimeout(start_training, 1);
}

function step_world() {
	b2d_world.Step(1 / 60, 10, 10);
	b2d_world.ClearForces();
}

function init() {
	upper_body = getNamedBodies(b2d_world, "upper_body")[0];
	for (let j = b2d_world.m_jointList; j; j = j.m_next) {
		if( j.name.indexOf('hip') > -1 || j.name.indexOf('knee') > -1 ) {
			leg_joints.push(j);
			j.start_angle = j.GetJointAngle();
		} else if( j.name.indexOf('shoulder') > -1 || j.name.indexOf('elbow') > -1 ) {
			arm_joints.push(j);
		}
	}
	all_joints = arm_joints.concat(leg_joints);
}
load_b2d_world();
init();
start_training();

var steps = 0;
var done = false;
function update_world() {
	if(draw_world == false)
		return;
	
	if(done == false && steps++ >2000) {
		console.log('done');
		done = true
	}
	var inputs = get_joint_angles().concat([upper_body.GetAngle()]);
	var outputs = networks[best_net].run(inputs);
	set_joint_motors(outputs);
		
	b2d_world.Step(1 / 60, 10, 10);
	
	//black background
	player_context.fillStyle = 'rgb(0,0,0)';
	player_context.clearRect( 0, 0, player_canvas.width, player_canvas.height );
	
	player_context.save();
	player_context.scale(1,-1);
	player_context.translate(0,-player_canvas.height);
	player_context.translate(player_offset.x,-player_offset.y);
	b2d_world.DrawDebugData();
	player_context.restore();
	
	b2d_world.ClearForces();
	
	requestAnimationFrame(update_world);
};
//update_world();
