var popSize = 20;

var networks = [];

// 9 inputs. 8 joint rotations: shoulder, elbow, hip, knee. & also the body's rotation
// 8 outputs, each new joint motor speed
// 8 hidden layers, 9 neurons per hidden layer
for(var i=0; i < popSize; i++)
	networks.push(new Brainwave.Network(3, 2, 8, 8));

var genetics = new Brainwave.Genetics(popSize, networks[0].getNumWeights());

// Use the weights generated by the Genetics object
for(var i=0; i<popSize; i++)
	networks[i].importWeights(genetics.population[i].weights);

function export_networks() {
	var exported = [];
	for(let i=0; i<networks.length; i++)
		exported.push(networks[i].exportWeights());
	return JSON.stringify(exported);
}
function import_networks(json_str) {
	var imported = JSON.parse(json_str);
	for(let i=0; i<networks.length && i<imported.length; i++) {
		networks[i].importWeights(imported[i]);
	}
}

//import_networks(saved_net);
	
var upper_body = null;
var arm_joints = [];
var hip_joints = [];
var knee_joints = [];
var leg_joints = [];
var all_joints = [];
var max_rads = 2*Math.PI;
function normalize_rads(rads) {
	return ((rads%max_rads)+max_rads)%max_rads;
}
function rad_to_fraction(rads) {
	return normalize_rads(rads)/max_rads;
}
function get_joint_angles(joints) {
	var arr = [];
	for(i=0; i<joints.length; i++)
		arr.push(rad_to_fraction(joints[i].GetJointAngle()));
	return arr;
}
function set_joint_motors(joints, arr) {
	// 0.5 = 0 speed
	// 1.0 = max torque
	// 0.0 = max torque in the negative direction
	
	for(i=0; i<joints.length; i++) {
		var j = joints[i];
		// make between -1 and 1
		var val = (arr[i] - 0.5)*2;
		var speed = val*j.GetMotorTorque();
		j.SetMaxMotorTorque(40);
		j.SetMotorSpeed(speed);
	}
}

function get_angle_closeness(ang1, ang2) {
	var diff = Math.abs( find_angle_difference(ang1, ang2) );
	return 1.0 - diff/max_rads;
}
function get_joint_straightness(j) {
	var range = Math.abs( j.GetUpperLimit() - j.GetLowerLimit() );
	range /= 2; // all joints start in middle, the farthest they can be away from center is halfway
	var cur_ang = j.GetJointAngle();
	var start_ang = j.start_angle;
	var diff = Math.abs( find_angle_difference(cur_ang, start_ang) );
	var straightness = 1.0 - (diff/range);
	
	return straightness;
}
function get_fitness() {
	var legs = 0;
	leg_joints.forEach(function(j) {
		legs += get_joint_straightness(j);
	});
	legs /= leg_joints.length;
	var body = get_angle_closeness(upper_body.GetAngle(), 0);
	return legs;
}

var best_net = 0;
var generation = 1;
var max_generations = 30;
console.log('b');
function start_training() {
	
	// For each network in the population, run a box2d simulation for 300 steps.
	// Fitness =
	// How well the upper body able to stay upright for how long
	// & How well the leg joints were about to stay upright for how long
	var worst_fitness = 1;
	var max_fitness = 0;
	var worst_net = 0;
	
	for (var i = 0; i < popSize; i++) {
		var fitness = 0;
		var num_steps = 2000;
		reset_b2d_world();
		for(var s=0; s<num_steps; s++) {
			step_world();
			
			var inputs = get_joint_angles(hip_joints).concat( [rad_to_fraction(upper_body.GetAngle())] );
			var outputs = networks[i].run(inputs);
			set_joint_motors(hip_joints, outputs);
			
			fitness += get_fitness();
		}
		
		fitness /= num_steps;

		if(fitness > 1)
			fitness = 1;
		else if(fitness < 0)
			fitness = 0;
		
		if(fitness > max_fitness) {
			max_fitness = fitness;
			best_net = i;
		}
		if( fitness < worst_fitness ) {
			worst_fitness = fitness;
			worst_net = i;
		}

		genetics.population[i].fitness = fitness;
	}
	
	console.log(generation+'/'+max_generations+', best: ['+best_net+'] at '+genetics.population[best_net].fitness+' f');
	console.log('      worst: ['+worst_net+'] at '+genetics.population[worst_net].fitness+' f');
	
	if(generation >= max_generations) {
		console.log('done training after '+generation+' generations.');
		reset_b2d_world();
		update_world();
		return;
	}

	// After you have decided on a fitness for each network, we can use the genetics
	// object to evolve them based on the results
	genetics.epoch(genetics.population);

	// Like at the start, import the weights generated by the Genetics object again.
	// This time they were 'evolved' based on which had the best fitness.
	for (var i = 0; i < popSize; i++)
		networks[i].importWeights(genetics.population[i].weights);
		
	++generation;
	setTimeout(start_training, 1);
}

function step_world() {
	b2d_world.Step(1 / 60, 10, 10);
	b2d_world.ClearForces();
	all_joints.forEach(function(j) {
		if(Math.abs(j.GetMotorSpeed()) < 0.1)
			j.SetMaxMotorTorque(0);
		else
			j.SetMaxMotorTorque(40);
	});
}

function init() {
	upper_body = getNamedBodies(b2d_world, "upper_body")[0];
	for (let j = b2d_world.m_jointList; j; j = j.m_next) {
		if( j.GetType() == 1 ) // revolute
			j.start_angle = j.GetJointAngle();
			
		if( j.name.indexOf('hip') > -1 || j.name.indexOf('knee') > -1 ) {
			leg_joints.push(j);
			if(j.name.indexOf('hip') > -1)
				hip_joints.push(j);
			else
				knee_joints.push(j);
		} else if( j.name.indexOf('shoulder') > -1 || j.name.indexOf('elbow') > -1 ) {
			arm_joints.push(j);
		}
	}
	all_joints = arm_joints.concat(leg_joints);
}
load_b2d_world();
init();
//start_training();


var steps = 0;
function update_world() {
	if(draw_world == false)
		return;
	
	var inputs = get_joint_angles(hip_joints).concat( [rad_to_fraction(upper_body.GetAngle())] );
	var outputs = networks[best_net].run(inputs);
	//set_joint_motors(hip_joints, outputs);
	
	step_world();
	++steps;
	if(steps == 2000)
		console.log('done');
	
	//black background
	player_context.fillStyle = 'rgb(0,0,0)';
	player_context.clearRect( 0, 0, player_canvas.width, player_canvas.height );
	
	player_context.save();
	player_context.scale(1,-1);
	player_context.translate(0,-player_canvas.height);
	player_context.translate(player_offset.x,-player_offset.y);
	b2d_world.DrawDebugData();
	player_context.restore();
	
	b2d_world.ClearForces();
	
	requestAnimationFrame(update_world);
};
update_world();
